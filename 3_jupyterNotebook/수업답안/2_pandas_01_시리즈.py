#!/usr/bin/env python
# coding: utf-8

# <img src='img/1_pandas.png' width=200 align='left'>

# - Python Data Analysis Library
# - 데이터 분석 및 가공을 위한 파이썬 라이브러리
# - series, DataFrame 등의 자료구조를 활용
# - R의 데이터프레임을 모방
# - 데이터를 수정하고 목적에 맞게 변경시키기 위해 사용
# - 데이터 프레임은 엑셀과 유사
# - Numpy를 사용하고 있어 계산이 빠름
# - 라이브러리 구성
#     - 여러종류의 클래스와 다양한 함수로 구성
#     - 시리즈와 데이터 프레임의 자료 구조 제공
#     - 시리즈(1차원 배열), 데이터프레임(2차원 배열)
# 
# - https://pandas.pydata.org/

# ### 판다스의 목적
# - 서로 다른 유형의 데이터를 공통된 포맷으로 정리하는 것
# - 행과 열로 이루어진 2차원 데이터프레임을 처리 할 수 있는 함수제공 목적
# - 실무 사용 형태 : 데이터 프레임

# In[1]:


# pandas 모듈 import
# 대부분의 코드에서 pandas를 pd 라는 별칭으로 사용
import pandas as pd
import numpy as np


# In[2]:


pd.__version__


# # pandas의 데이터 구조
# 
# 1. Series 데이터
# 2. 데이터 프레임

# ![pandas_dataType](img/2_pandas_데이터구조.png)

# - 출처 : https://www.kdnuggets.com/2017/01/pandas-cheat-sheet.html

# # 1. Series 데이터

# **Series**
# 
# - pandas의 기본 객체 중 하나
# - numpy의 ndarray를 기반으로 인덱싱 기능을 추가하여 1차원 배열을 나타냄
# - index를 지정하지 않을 시, 기본적으로 ndarray와 같이 0-based 인덱스 생성, 지정할 경우 명시적으로 지정된 index를 사용
# - 같은 타입의 0개 이상의 데이터를 가질 수 있음

# 1. 자료구조: 시리즈
#     - 데이터가 순차적으로 나열된 1차원 배열 형태
#     - 인덱스(index)와 데이터 값(value)이 일대일로 대응
#     - 딕셔너리와 비슷한 구조 : {key(index):value}
# 2. 시리즈의 인덱스
#     - 데이터 값의 위치를 나타내는 이름표 역할
# 3. 시리즈 생성 : 판다스 내장함수인 Series()이용
#     - 리스트로 시리즈 만들기
#     - 딕셔너리로 시리즈 만들기
#     - 튜플로 시리즈 만들기

# ### Series 생성하기
# 
# **pd.Series(seq_data) 함수 이용**
# 
# - seq_data : 리스트, 딕셔너리, 튜플 타입 데이터

# **1) seq_data 를 이용하여 Series 생성하기**
# 
# : index는 기본적으로 0부터 자동적으로 생성

# - **리스트로 시리즈 만들기**

# In[3]:


# Series 함수 이용 : 리스트로 만들기
# pd.Series(1차원 배열 : 리스트)

# 인덱스 없이 Series를 생성하면 자동으로 0부터 시작되는 index를 만들어 줌
s = pd.Series([1,2,3])
s


# ![series](img/3_pandas_series1.png)
# 

# In[4]:


# 정수값을 갖은 리스트로 시리즈 생성
s1 = pd.Series([10,20,30,40,50])
s1


# In[5]:


# 문자열을 갖은 리스트로 시리즈 생성
s2 = pd.Series(['A','B','C'])
s2


# In[6]:


# 문자열을 갖은 리스트로 시리즈 생성
s2 = pd.Series('A B C'.split())
s2


# - **범위를 시리즈의 value 생성하는 데 사용하기**
#     - range() / np.arange() 함수 사용

# In[7]:


# range()를 이용하여 정수범위 자료를 시리즈로 생성
s = pd.Series(range(10,14))
s


# In[8]:


# arange()를 이용하여 정수범위 자료를 시리즈로 생성

s = pd.Series(np.arange(200))
s


# - **결측값을 포함해서 시리즈 만들기**
#     - 결측값 NaN - numpy 라는 모듈에서 생성할 수 있음
#     - 결측값 생성 위해서는 numpy 모듈 import

# In[9]:


### pandas와 numpy 패키지는 import 해서 사용
# import numpy as np

s = pd.Series([1,2,3,np.nan,6,8])
s

# 인덱스 : 0부터 시작하는 정수값


# **2) 인덱스 명시해서 시리즈 만들기**
# 
# - 숫자 인덱스 지정
#     - s = pd.Series([값1, 값2, 값3, ... ], index=[1,2,3, ...])

# In[10]:


# 숫자 인덱스 지정
s1 = pd.Series([10,20,30], index=[1,2,3])
s1


# - 문자 인덱스 지정

# In[11]:


# 문자 인덱스 지정
s2 = pd.Series([95, 100, 88], index=['홍길동','이몽룡','성춘향'])
s2


# **3) 인덱스 활용**
# 
# - **시리즈의 index**
#     - 시리즈의 index는 index 속성으로 접근 : **시리즈.index**

# In[12]:


# 시리즈.index
s1.index


# In[13]:


s2.index


# In[14]:


s = pd.Series([9904312, 3448737, 289045, 2466052],
            index=["서울","부산","인천","대구"]) 
s.index

# dtype='object' :  datatype = '문자열객체'


# - **시리즈.index.name 속성**
#     - 시리즈의 인덱스에 이름을 붙일 수 있음

# In[15]:


print(s.index.name)


# In[16]:


s.index.name = '도시'
s


# **4) 시리즈의 값**
# - numpy 자료구조 : 1차원 배열 
# - values 속성으로 접근 : **시리즈.values**

# In[17]:


# 시리즈 값
s.values


# **5) 시리즈.name 속성**
# - 시리즈 데이터에 이름을 붙일 수 있음
# - name 속성은 값의 의미 전달에 사용

# In[18]:


# 시리즈의 name 속성 출력
print(s.name)


# In[19]:


# 시리즈 name 속성 변경
s.name = '인구수'
s


# ### 시리즈 인덱싱(indexing)
# 
# - 인덱싱 : 데이터에서 특정한 데이터를 골라내는 것

# #### 시리즈의 인덱싱 종류
# 1. 정수형 위치 인덱스(integer position)
# 2. 인덱스 이름(index name) 또는  인덱스 라벨(index label)
# 
#     - 인덱스 별도 지정하지 않으면 0부터 시작하는 정수형 인덱스가 지정됨
# 
# ##### 원소접근
#     - 정수형 인덱스 : 숫자 s[0]
#     - 문자형 인덱스 : 문자 s['인천'] , s.인천   

# In[21]:


# 정수형 인덱스 접근
print(s.index)
s[0]
# 인덱스 서울의 value가 접근


# In[22]:


# 문자형 인덱스 접근
s['서울']


# In[24]:


# 한 줄에 위치 인덱스와 문자 인덱스를 동시에 접근
s[2], s['대구']


# ##### 리스트 이용 인덱싱
# - 자료의 순서를 바꾸거나 특정자료 여러개를 선택할 수 있다.
# - 인덱스값 여러 개를 이용해 접근시 [ ]안에 넣는다

# In[25]:


# 여러 개 접근
s[[1,2]]


# In[26]:


s[['서울','대구']]


# ##### 문자 인덱스를 이용한 인덱싱
# - .연산자를 이용하여 접근가능 : 객체명.문자인덱스명

# In[29]:


# 인덱스를 문자값으로 지정한 시리즈
s.서울


# In[30]:


# 인덱스가 a,b,c
s1 = pd.Series(range(3), index=['a','b','c'])
s1


# In[31]:


s1.a


# ### 시리즈 슬라이싱(slicing)
# 
# - 정수형 위치 인덱스를 사용한 슬라이싱
#     - 시리즈[start : stop+1]
# 
# 
# - 문자(라벨)인덱스 이용 슬라이싱
#     - 시리즈['시작라벨' : '끝라벨']  : 표시된 라벨 범위 모두 추출

# In[32]:


#값 2개 추출 - [1,2]

s[1:3]


# In[33]:


# 문자 인덱스를 이용한 슬라이싱
# 2 ~4번째 값 (3개 값)

s['부산':'대구']


# ### 인덱스 통한 시리즈 데이터 업데이트

# In[34]:


s


# In[35]:


# '서울' 데이터 변경
s['서울']=10000000  # s.서울=10000000, s[0]=10000000
s


# ### 인덱스 재사용

# In[36]:


s1 = pd.Series(np.arange(4), s.index)
s1


# ### 시리즈 연산

# **벡터화 연산**
# - numpy 배열처럼 pandas의 시리즈도 벡터화 연산 가능 
# - 벡터화 연산이란 집합적 자료형의 원소 각각을 독립적으로 계산을 진행하는 방법
#     - 단, 연산은 시리즈의 값에만 적용되며 인덱스 값은 변경 불가

# In[37]:


# 시리즈와 스칼라의 합
pd.Series([1,2,3]) +4


# In[38]:


# s 시리즈의 값을 1/1000000로 변경
s/1000000

# s 시리즈의 모든 value에 대하여 각각 연산을 진행


# **벡터화 인덱싱 : Boolean selection**
#   - boolean Series가 []와 함께 사용되면 True 값에 해당하는 값만 새로 반환되는 Series객체에 포함됨
#   - 다중조건의 경우, &(and), |(or)를 사용하여 연결 가능

# In[44]:


# 벡터화 인덱싱
# s 시리즈 값 중 2500000 보다 크고 5000000 보다 작은 원소를 추출
# 각 원소의 값 모두 각각 조건식을 확인 하여 결과가 True인 원소만 추출

s[(s > 2500000) & (s < 5000000)]
# (s > 25e5) & (s < 50e5)


# In[45]:


s0 = pd.Series(np.arange(10), np.arange(10)+1)
s0


# In[46]:


# 5 보다 큰가?
s0 > 5


# In[47]:


# 5보다 큰 요소 추출
s0[s0>5]


# In[48]:


# 짝수 추출
s0[s0%2==0]
# s0[(s0 % 2  == 0)&(s0 != 0)]


# In[49]:


s0


# In[50]:


# 인덱스가 5이상인 것은?
s0.index > 5


# In[51]:


# 인덱스가 5이상인 요소 추출
s0[s0>5]


# In[52]:


# 값이 5보다 크고 8보다 작은 요소 추출
s0[(s0>5) & (s0<8)]


# In[53]:


# 값이 7이상인 수들의 합을 구하기
s0[s0 >=7].sum()


# In[54]:


# 값이 7이상인 수들의 갯수 (True인 결과)
(s0 >=7).sum()


# **두 시리즈간의 연산**

# In[56]:


num_s1 = pd.Series([1,2,3,4],index=['a','b','c','d'])
num_s1


# In[57]:


num_s2 = pd.Series([5,6,7,8],index=['b','c','d','a'])
num_s2


# - 시리즈간의 연산은 같은 인덱스를 찾아 연산을 진행
# - 동일한 인덱스는 연산을 진행하고 나머지 인덱스는 연산처리가 불가 해 NaN 값 처리

# - 시리즈 + 시리즈
#     - 같은 인덱스를 찾아 + 연산을 진행

# In[58]:


# 두 시리즈에 대한 + 연산
num_s1 + num_s2


# - 시리즈 + 시리즈
#    - 동일한 인덱스는 연산을 진행하고 나머지 인덱스는 연산처리가 불가 해 NaN 값 처리

# In[59]:


num_s3 = pd.Series([5,6,7,8],index=['e','b','f','g'])
num_s4 = pd.Series([1,2,3,4],index=['a','b','c','d'])


# In[60]:


# 두 시리즈의 + 연산
num_s3 + num_s4


# - 시리즈 - 시리즈

# In[61]:


# 두 시리즈의 -연산
num_s3 - num_s4


# - 시리즈의 values 속성을 이용한 연산
#     - values 속성을 사용하면 시리즈의 형태가 사라지므로 동일 위치 원소들끼리 연산
#     - 시리즈.values 는 array 형태 반환

# In[66]:


a = num_s3.values
a


# In[62]:


# 두 시리지 values 들간의 - 연산
num_s3.values - num_s4.values


# **in 연산자/ for 반복문 사용**

# - 시리즈 객체는 라벨(문자)에 의해 인덱싱이 가능
# - 실질적으로는 라벨을 key로 가지는 딕셔너리 형과 같다고 볼 수 있음
# - 딕셔너리에서 제공하는 대부분의 연산자 사용 가능
#     - in 연산자 : T / F
#     - for 루프를 통해 각 원소의 key와 value에 접근

# In[67]:


s


# In[68]:


# 인덱스가 서울인 원소가 시리즈에 있는지
'서울' in s


# In[70]:


# 인덱스가 대전인 원소가  시리즈에 있는지
'대전' in s


# In[71]:


# 인덱스가 대전인 원소가 시리즈에 없는지
'대전' not in s


# In[72]:


# 딕셔너리의 items()과 같은 함수가 시리즈에도 있음
s.items() # zip 객체


# In[52]:


# list로 변환 후 확인
list(s.items()) 


# In[73]:


# 시리즈 각 원소 출력
for k, v in s.items():
    print(f'{k}={v}')


# ### 딕셔너리로 시리즈 만들기
# - **Series({key1:value1, key2:value2, key3:value3, ... })**
#     - 인덱스 -> key
#     - 값 -> value

# In[74]:


scores = {'홍길동':96,'이몽룡':100,'성춘향':88}
s = pd.Series(scores)
s


# In[75]:


city = {'서울':9631482,'부산':3393191,'인천':2632035,'대전':1490158}
s = pd.Series(city)
s


# **딕셔너리 기반으로 생성한 시리즈 인덱스 설정**

# - 딕셔너리의 원소는 순서를 갖지 않는다.
#     - 딕셔너리로 생성된 시리즈의 원소도 순서가 보장되지 않는다.
#     - 만약 순서를 보장하고 싶으면 인덱스를 리스트로 지정해야 한다.

# In[81]:


# 딕셔너리 기반으로 생성한 시리즈 인덱스 설정
s = pd.Series(city, index=['부산','인천','서울','대전'])
s


# ### 시리즈 데이터의 갱신,추가, 삭제
# 
# : 인덱싱을 이용하면 딕셔너리 처럼 갱신, 추가 가능

# In[77]:


s


# - 시리즈 데이터 갱신

# In[78]:


# s2 시리즈의 부산의 인구 값을 1630000으로 변경
s['부산']= 1630000
s


# - 시리즈 데이터 삭제

# In[82]:


# 데이터를 삭제할 때도 딕셔너리처럼 del 명령을 사용
del s['부산']
s


# - 시리즈 데이터 추가

# In[83]:


# 시리즈에 새로운 값 추가
s['대구']=1875000
s


# ### Series 함수

# **Series size, shape, unique, count, value_counts 함수**
#  - size : 시리즈 원소 개수 반환
#  - shape : 튜플형태로 shape 반환
#  - unique(): 유일한 값만 ndarray로 반환
#  - count() : NaN을 제외한 개수를 반환
#  - mean() : NaN을 제외한 평균 
#  - value_counts() : NaN을 제외하고 각 값들의 빈도를 반환 

# In[84]:


s1 = pd.Series([1, 1, 2, 1, 2, 2, 2, 1, 1, 3, 3, 4, 5, 5, 7, np.NaN])
s1


# - 시리즈 원소 크기

# In[85]:


s1.size


# In[86]:


len(s1)


# In[87]:


s1.shape
# 결과가 튜플형태로 (차원,)


# - **unique()** : 시리즈의 유일한 값 반환

# In[88]:


s1.unique()


# - **count()** : NaN을 제외한 개수를 반환

# In[89]:


s1.count()


# - **mean()** : 데이터의 평균

# In[90]:


s1.mean()


# In[91]:


# numpy의 1차원 데이터 생성하고 평균을 계산
a = np.array([2, 2, 2, 2, np.NaN])
a.mean()


# In[92]:


# 시리즈의 경우 평균은 Nan을 제외하고 계산
b = pd.Series(a)   # numpy 데이터를 시리즈로 변경
b


# In[93]:


b.mean()


# - **value_counts()** : 그룹핑된 원소별 개수 

# In[94]:


# 각 원소들의 그룹별 개수를 셈(빈도계산)
s1.value_counts()


# ### 날짜 인덱스를 이용하여 시리즈 생성

# In[95]:


# 날짜 인덱스를 이용하여 시리즈 만들기
# 날짜 표시 :'년-월-일' 형태의 문자열로 표시

index_date = ['2021-10-07','2021-10-08','2021-10-09','2021-10-10']

s = pd.Series([200, 195, np.nan, 205], index=index_date)
s


# In[72]:


type(s.index[0]) # 문자열 형태


# **날짜 생성 함수 : date_range()**

# - 판다스 패키지의 date_range 함수 (날짜생성)
# - pd.date_range(start=None, end=None, periods=None, freq='D')
#     - start : 시작날짜
#     - end : 끝날짜
#     - periods : 날짜 생성기간
#     - freq : 날짜 생성 주기, 기본값은 'D' (Day)
#     - start는 필수 옵션/end나 periods는 둘 중 하나가 있어야 함

# freq 옵션

# ![freq_option](img/4_pandas.date_freq.png)

# - 일별 간격으로 날짜 생성

# In[97]:


# dtype='datetime64[ns] 데이트타임 형태로 생성

date = pd.date_range(start='2021-10-01', end='2021-10-20')
date


# In[98]:


type(date)


# In[99]:


# 하루 주기로 '2021-10-01'에서 '2021-10-20' 사이의 일자 생성

pd.date_range(start='2021-10-01', end='2021-10-20', freq='D')


# - 3일 간격의 날짜 생성

# In[100]:


# '2021-01'에서 '2021-10-20' 사이의 3일 간격의 일자 생성

pd.date_range(start='2021-10-01', end='2021-10-20', freq='3D')


# - 주간격으로 날짜 생성
#     - 지정한 일자가 포함된 주의 요일 시작 일자 기준으로 일주일 주기로 생성
#     - freq='W' : 일요일 기준으로 일주일 주기로 생성
#     - freq='W-MON' : 월요일 기준으로 일주일 주기로 생성

# In[101]:


# 2021-10-01일을 기준으로 1주일씩 증가하는 일자 생성 : 시작일(일요일)
#'2021-10-01'은 금요일

pd.date_range(start='2021-10-01', end='2021-10-20', freq='W')


# In[102]:


# 2021-10-01일을 기준으로 1주일씩 증가하는 일자 생성 :  시작일(일요일)
#'2021-10-01'은 금요일

pd.date_range(start='2021-10-01', end='2021-10-20', freq='W-SUN')


# In[104]:


# 2021-10-01일을 기준으로 1주일씩 증가하는  일자 생성 : 시작일(금요일)
#'2021-10-01'은 금요일

pd.date_range(start='2021-10-01', end='2021-10-20', freq='W-FRI')


# In[105]:


# 2021-10-01일을 기준으로 1주일씩 증가하는  일자 생성 : 시작일(월요일)
#'2021-10-01'은 금요일

pd.date_range(start='2021-10-01', end='2021-10-20', freq='W-MON')


# In[106]:


# 2021-10-07일을 기준으로 1주일씩 증가하는 4개의 1주 시작일(월요일)

pd.date_range(start='2021-10-07', periods=4 , freq='W-MON')


# - 월간격으로 날짜 생성
#     - freq='M' : 월말 날짜 기준 주기
#     - freq='BM' : 업무 월말 날짜 기준 주기
#     - freq='MS' : 월초 날짜 기준 주기

# In[109]:


# 2021-10-01 기준으로 한 달 간격의 일자 4개 생성 : 월말기준

pd.date_range(start='2021-10-01', periods=4 , freq='M')


# In[111]:


# 2021-10-07 기준으로 한 달 간격의 일자 4개 생성 : 월초기준

pd.date_range(start='2021-10-07', periods=4 , freq='MS')


# In[112]:


# 2021-10-01 기준으로 세 달 간격의 일자 4개 생성 : 월말기준

pd.date_range(start='2021-10-01', periods=4 , freq='3M')


# In[113]:


#  2개월 월초주기로 12개의 날짜 생성

pd.date_range(start='2018-10-01', periods=12, freq='2MS')


# - 분기별 주기로 날짜 생성
#     - freq = Q : 분기 끝 날짜 기준 주기
#     - freq = BQ : 업무 분기 끝 날짜 기준 주기
#     - freq = QS : 분기 시작 날짜 기준 주기

# In[114]:


# 분기 시작일을 기준으로 4개의 분기 시작일 생성

pd.date_range(start='2018-10-01',periods=4, freq='QS') 


# In[115]:


# 분기 마지막일을 기준으로 4개의 분기 시작일 생성

pd.date_range(start='2018-10-01',periods=4, freq='Q') 


# - 연별 주기로 날짜 생성
#     - freq = A : 일년 끝 날짜 기준 주기
#     - freq = BA : 업무 일년 끝 날짜 기준 주기
#     - freq = AS : 일년 시작 날짜 기준 주기

# In[116]:


# 연도 첫날 기준으로 4개의 연도 첫날짜 생성

pd.date_range(start='2018-01-01',periods=4, freq='AS') 


# In[117]:


# 연도 마지막날 기준으로 4개의 연도 첫날짜 생성

pd.date_range(start='2018-01-01',periods=4, freq='A') 


# In[118]:


# 2018-01-20일 부터 연초 기준으로 4개의 날짜 생성

pd.date_range(start='2018-01-20',periods=4, freq='AS')


# - 시간 기준 주기로 날짜와 시간 생성
#     - freq = H : 시간 주기
#     - freq = BH : 업무 시간 주기
#     - freq = T 또는 min : 분 주기
#     - freq = S : 초 주기

# In[119]:


# 2022-01-07일 08:00 부터 시간 기준으로 10개의 날짜 생성

pd.date_range(start='2022-01-07 08:00', periods=10, freq='H')


# In[120]:


# 2022-01-07일 08:00 부터 업무시간 기준으로 10개의 날짜 생성
# 업무시간기준 :  9 to 5 로 설정되어 있음

pd.date_range(start='2022-01-07 08:00', periods=10, freq='BH')


# In[121]:


# 30분 단위 : 30T로 해도 됨
pd.date_range(start='2022-01-20 08:00',periods=10, freq='30min')


# In[122]:


# 10초 단위로 증가
pd.date_range(start='2022-01-20 08:00',periods=10, freq='10S')


# ###### Series 끝
